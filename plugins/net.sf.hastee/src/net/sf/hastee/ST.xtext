grammar net.sf.hastee.ST with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate st "http://www.sf.net/hastee/ST"

// entry point
Group:
	(imports+=Import)*
	(members+=TopDeclaration)*;

Import:
	'import' uri=ExprString;

Declaration: name=ID;

TopDeclaration:
	decl = Declaration
	body = DeclarationBody;

DeclarationBody: TemplateDeclaration | DictionaryDeclaration;

// top-level elements: TemplateNamed and Dictionary
TemplateDeclaration:
	'(' ( (attributes += Declaration (',' attributes += Declaration)* (',' defaultAttributes += DefaultAttribute)*)
		| (defaultAttributes += DefaultAttribute (',' defaultAttributes += DefaultAttribute)*))?
	')' '::='
	definition = TemplateDef;

DictionaryDeclaration:
	'::=' '[' pairs+=DictPair (',' pairs+=DictPair)* ']';

DictPair:
	key=ExprString ':' definition = TemplateDef;

TemplateDef:
	(('<<' template = Template '>>')
	| ('"' template = Template '"'));

Template:
	{Template} (elements+=Element)*;

DefaultAttribute:
	decl = Declaration '=' defaultValue = DefaultValue;

DefaultValue:
	string=ExprString
	| bool='true'
	| bool='false';

// anonymous template
TemplateAnonymous:
	'{'
	(arguments += Declaration (',' arguments += Declaration)* '|')?
	template = Template
	'}';

// elements allowed in named, string, and anonymous templates
Element:
	Test
	| ExpressionElement
	| TextContents;

TextContents: contents = TEXT;

ExpressionElement:
	'<' expression=Expression (';' options+=Option (',' options+=Option)*)? '>';

// if/elseif/else/endif test
Test:
	'<' 'if' '(' c1+=Conditional ')' '>'
	t1+=Template
	('<' 'elseif' '(' c2+=Conditional ')' '>' t2+=Template)*
	('<' 'else' '>' t3=Template)?
	'<' 'endif' '>';

// conditional expressions
Conditional:
	AndConditional ({ConditionalBinary.left=current} operator='||' right=AndConditional)*;

AndConditional returns Conditional:
	NotConditional ({ConditionalBinary.left=current} operator='&&' right=NotConditional)*;

NotConditional returns Conditional:
	{ConditionalUnary} unaryOperator='!' condition=ConditionalExpr
	| expression=ExprMember;

ConditionalExpr returns Conditional:
	{ConditionalExpr} expression=NotConditionalExpr
	| '(' Conditional ')';

NotConditionalExpr:
	expr=ExprAttribute ('.' properties+=Property)*;

Property:
	_name=ID // name is private
	| '(' indirect=ExprMap ')';

// expression
Expression:
	ExprMap;

ExprNoComma:
	member=ExprMember (':' map=MapTemplateRef)?;

Option:
	_name=ID ('=' value=ExprNoComma)?; // option name is private

// TODO: add stuff here
ExprMap:
	members+=ExprMember
	((',' members+=ExprMember)* ':' template=MapTemplateRef)?;

MapTemplateRef:
	ExprReference
	| TemplateAnonymous
	| ExprIndirect;

ExprMember:
	root=ExprInclude ('.' properties+=Property)*;

ExprInclude:
	ExprReference
	| ExprPrimary;

// call to template
ExprReference:
	objRef=[Declaration] '(' args=ExprTemplateArgs? ')';

ExprTemplateArgs:
	NamedArgs
	| Args;

NamedArgs:
	args+=NamedArg (',' args+=NamedArg)*;

NamedArg returns Arg:
	attribute=[Declaration] '=' value=ExprNoComma;

Args:
	args+=Arg (',' args+=Arg)*;

Arg:
	value=ExprNoComma;

// primary expression
ExprPrimary:
	ExprAttribute
	| ExprString
	| ExprTemplateAnonymous
	| ExprList
	| ExprIndirect;

ExprAttribute:
	attribute=[Declaration];

ExprString: contents = STRING;

ExprTemplateAnonymous:
	template=TemplateAnonymous;

ExprIndirect:
	'(' expr=Expression ')' ('(' args=ExprTemplateArgs ')')?;

ExprList:
	'[' values+=ExprNoComma (',' values+=ExprNoComma)* ']';

// any character that is not anywhere else in the grammar
// does not matter which one, since this is overriden by our lexer anyway
terminal TEXT : '`';
