
tta(tta, options) ::= <<
\<?xml version="1.0" encoding="UTF-8" standalone="no" ?\>
\<adf version="1.7"\>
	<tta.buses: bus(); separator="\n\n">
	
	<tta.sockets: socket(); separator="\n\n">
	
	<tta.functionUnits: functionUnit(); separator="\n\n">
	
	<tta.registerFiles: registerFile(); separator="\n\n">
	
	<if(tta.data)><addressSpace(tta.data)><endif>
	
	<if(tta.program)><addressSpace(tta.program)><endif>
	
	<if(tta.gcu)><globalControlUnit(tta.gcu)><endif>
\</adf\>
>>

bus(bus) ::= <<
\<bus name="<bus.name>"\>
	\<width\><bus.width>\</width\>
	<bus.guards: guard(); separator="\n">
	<bus.segments: segment(); separator="\n">
	<shortImmediate(bus.shortImmediate)>
\</bus\>
>>

guard(guard) ::= <<
\<guard\>
	<expression(guard)>
\</guard\>
>>

expression(expr) ::= <<
<if(expr.exprTrue)
><exprTrue()><
elseif(expr.exprFalse)
><exprFalse()><
elseif(expr.exprUnary)
><exprUnary(expr)><
elseif(expr.exprBinary)
><exprBinary(expr)><
endif>
>>

exprTrue() ::= <<
\<always-true/\>
>>

exprFalse() ::= <<
\<always-false/\>
>>

exprUnary(expr) ::= <<
<if(expr.simple)>\<simple-expr\><else>\<inverted-expr\><endif>
	<term(expr.term)>
<if(expr.simple)>\</simple-expr\><else>\</inverted-expr\><endif>
>>

exprBinary(expr) ::= <<
<if(expr.and)>\<and-expr\><else>\<or-expr\><endif>
	<exprUnary(expr.e1)>
	<exprUnary(expr.e2)>
<if(expr.and)>\</and-expr\><else>\</or-expr\><endif>
>>

term(term) ::= <<
<if(term.termBool)
><termBool(term)><
elseif(term.termUnit)
><termUnit(term)><
endif>
>>

termBool(term) ::= <<
\<bool\>
	\<name\><term.register.name>\</name\>
	\<index\><term.index>\</index\>
\</bool\>
>>

termUnit(term) ::= <<
\<unit\>
	\<name\><term.functionUnit.name>\</name\>
	\<port\><term.port.name>\</port\>
\</unit\>
>>

segment(segment) ::= <<
\<segment name="<segment.name>"\>
	\<writes-to/\>
\</segment\>
>>

shortImmediate(shortImmediate) ::= <<
\<short-immediate\>
	\<extension\>zero\</extension\>
	\<width\><shortImmediate.width>\</width\>
\</short-immediate\>
>>

socket(socket) ::= <<
\<socket name="<socket.name>"\>
	<socket.connectedSegments: socketSegment()>
\</socket\>
>>

socketSegment(segment) ::= <<
<if(socket.input)>\<reads-from\><else>\<writes-to\><endif>
	\<bus\><segment.bus.name>\</bus\>
	\<segment\><segment.name>\</segment\>
<if(socket.input)>\</reads-from\><else>\</writes-to\><endif>
>>

functionUnit(functionUnit) ::= <<
\<function-unit name="<functionUnit.name>"\>
	<functionUnit.ports: port(); separator="\n">
	<functionUnit.operations: { operation | <operation(operation, false)> }; separator="\n">
	<if(functionUnit.addressSpace)>\<address-space\><functionUnit.addressSpace.name>\</address-space\><else>\<address-space/\><endif>
\</function-unit\>
>>

registerFile(register) ::= <<
\<register-file name="<register.name>"\>
	\<type\>normal\</type\>
	\<size\><register.size>\</size\>
	\<width\><register.width>\</width\>
	\<max-reads\><register.maxReads>\</max-reads\>
	\<max-writes\><register.maxWrites>\</max-writes\>
	<register.ports: { port | <port(port, false)> }; separator="\n">
\</register-file\>
>>

port(port, width=true, special=false) ::= <<
\<<if(special)>special-<endif>port name="<port.name>"\>
	<connectSocket(port.inputSocket)>
	<connectSocket(port.outputSocket)>
	<if(width)>\<width\><port.width>\</width\><endif>
	<if(port.trigger)>\<triggers/\><endif>
	<if(port.opcodeSelector)>\<sets-opcode/\><endif>
\</<if(special)>special-<endif>port\>
>>

connectSocket(socket) ::= <<
<if(socket)>\<connects-to\><socket.name>\</connects-to\><endif>
>>

addressSpace(addressSpace) ::= <<
\<address-space name="<addressSpace.name>"\>
	\<width\><addressSpace.width>\</width\>
	\<min-address\><addressSpace.minAddress>\</min-address\>
	\<max-address\><addressSpace.maxAddress>\</max-address\>
\</address-space\>
>>

globalControlUnit(gcu) ::= <<
\<global-control-unit name="gcu"\>
	<gcu.ports: port(); separator="\n">
	<port(gcu.returnAddress, true, true)>
	\<return-address\><gcu.returnAddress.name>\</return-address\>
	<gcu.operations: { operation | <operation(operation, true)> }; separator="\n">
	\<address-space\><gcu.addressSpace.name>\</address-space\>
	\<delay-slots\><gcu.delaySlots>\</delay-slots\>
	\<guard-latency\><gcu.guardLatency>\</guard-latency\>
\</global-control-unit\>
>>

operation(operation, control=false) ::= <<
\<<if(control)>ctrl-<endif>operation\>
	\<name\><operation.name>\</name\>
	<operation.ports: { port | \<bind name="<operation.portToIndexMap.(port)>"\><port.name>\</bind\> }; separator="\n" >
	\<pipeline\>
		<operation.pipeline: element(); separator="\n">
	\</pipeline\>
\</<if(control)>ctrl-<endif>operation\>
>>

element(element) ::= <<
<if(element.reads)
><reads(element)><
elseif(element.writes)
><writes(element)><
elseif(element.resource)
><resource(element)><
endif>
>>

reads(element) ::= <<
\<reads name="<operation.portToIndexMap.(element.port)>"\>
	\<start-cycle\><element.startCycle>\</start-cycle\>
	\<cycles\><element.cycles>\</cycles\>
\</reads\>
>>

writes(element) ::= <<
\<writes name="<operation.portToIndexMap.(element.port)>"\>
	\<start-cycle\><element.startCycle>\</start-cycle\>
	\<cycles\><element.cycles>\</cycles\>
\</writes\>
>>

resource(element) ::= <<
\<resource name="element.name"\>
	\<start-cycle\><element.startCycle>\</start-cycle\>
	\<cycles\><element.cycles>\</cycles\>
\</resource\>
>>
