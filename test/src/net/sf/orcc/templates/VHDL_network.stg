///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
portType(port, IOtype, dataType) ::=<<
<if(port.type.bool)
><port.name>_<dataType>  :<IOtype>std_logic;<
else
><port.name>_<dataType>  :<IOtype>std_logic_vector(<port.type.size> -1 downto 0);<
endif>
>>

SignalType(instance, port, dataType) ::=<<
<if(port.type.bool)
>signal <instance.id>_<port.name>_<dataType>   : std_logic;<
else
>signal <instance.id>_<port.name>_<dataType>   : std_logic_vector(<port.type.size> -1 downto 0);<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of the TOP Network
///////////////////////////////////////////////////////////////////////////////
printNetworkPorts(network) ::= <<
<network.inputs.list: printNetPortsInput(); separator="\n">
<network.outputs.list: printNetPortsOutput(); separator="\n">
>>

printNetPortsInput(port) ::= <<
<portType(port=port, IOtype=" in  ", dataType="data")>
<port.name>_send  : in  std_logic;
<port.name>_ack   : out std_logic;
>>

printNetPortsOutput(port) ::= <<
<portType(port=port, IOtype=" out ", dataType="data")>
<port.name>_send  : out std_logic;
<port.name>_ack   : in  std_logic;
>>



//////////////////////////////////////////////////////////////////////////////
// Print signals
//////////////////////////////////////////////////////////////////////////////
tryPrintSignals(outgoingMap) ::= <<
<outgoingMap.keys: {instance | <checkInstanceType(instance)>}>
>>

checkInstanceType(instance) ::= <<
<if (instance.actor)
>                                            -- Actor : <instance.id>
<printSignals(inputs=instance.actor.inputs,
              outputs=instance.actor.outputs)><
elseif (instance.broadcast)
>                                            -- Broadcast : <instance.id>
<printSignals(inputs=instance.broadcast.inputs.list,
              outputs=instance.broadcast.outputs.list)><
elseif (instance.network)
>                                            -- Network : <instance.id>
<printSignals(inputs=instance.network.inputs.list,
              outputs=instance.network.outputs.list)><
endif>
>>

printSignals(inputs, outputs) ::= <<
<if(!inputs.empty)
><network.incomingMap.(instance).values: printInSignals()><
endif><
if(!outputs.empty)
><outgoingMap.(instance).values: {connections|<connections:{connection | <printOutSignals(connection=connection, map=network.successorsMap.(instance))>}>}><
endif>
>>

// print internal signals when necessary
printInSignals(connection) ::= <<
<if (instance.broadcast)
>
<broadcastType(connection=connection, name=instance.id, direction="fromBroad")>
<
endif>
<printInSignal(connection=connection, map=network.predecessorsMap.(instance))>
>>

printInSignal(connection, map) ::= <<
<if(map.(connection.target))
><SignalType(instance=instance, port=connection.target, dataType="data")>
signal <instance.id>_<connection.target.name>_send   : std_logic;
signal <instance.id>_<connection.target.name>_ack    : std_logic;
<endif>
>>

printOutSignals(connection, map) ::= <<
<if (instance.broadcast)
><
else
><printOutSignal(connection=connection, map=map)><
endif>
>>

printOutSignal(connection, map) ::= <<
<if(map.(connection.source) && connection.attributes)
><SignalType(instance=instance, port=connection.source, dataType="data")>
signal <instance.id>_<connection.source.name>_send   : std_logic;
signal <instance.id>_<connection.source.name>_ack    : std_logic;
<endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print FIFOs instantiation
///////////////////////////////////////////////////////////////////////////////
assignFifos(edges) ::= <<
<edges: assignFifo()>
>> 

assignFifo(edge) ::= <<
<tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>> 

tryAssignFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)
><doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))><
endif>
>>

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
<if(edge.size)>
fifo_<count> : entity work.fifo_generic 
  generic map (
    depth =\> <edge.size>,
  <if(targetPort.type.bool)
>  width =\> 1)<
  else
>  width =\> <targetPort.type.size>)<
  endif>

  port map (
    wr_data    =\> <source.id>_<sourcePort.name>_send, 
  <if(targetPort.type.bool)
>  data_in(0) =\> <source.id>_<sourcePort.name>_data,<\n><
  else
>  data_in    =\> <source.id>_<sourcePort.name>_data,<\n><
  endif>
    wr_clk     =\> clock, 
    wr_ack     =\> <source.id>_<sourcePort.name>_ack, 
  <if(targetPort.type.bool)
>  data_out(0)=\> <target.id>_<targetPort.name>_data,<\n><
  else
>  data_out   =\> <target.id>_<targetPort.name>_data,<\n><
  endif
>    rd_clk     =\> clock, 
    send       =\> <target.id>_<targetPort.name>_send, 
    rd_ack     =\> <target.id>_<targetPort.name>_ack,  
    reset_n    =\> reset_n);<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// print actors and networks instantiation
///////////////////////////////////////////////////////////////////////////////
PrintNetworksAndActors(outgoingMap) ::= <<
<outgoingMap.keys: {instance | <checkNetworkOrActors(instance=instance)>}>
>>

checkNetworkOrActors(instance) ::= <<
<if (instance.actor)
><printInstances(name=instance.actor.simpleName,
				 inputs=instance.actor.inputs,
                 outputs=instance.actor.outputs)>
                 
                 <
elseif (instance.network)
><printInstances(name=instance.network.name,
				 inputs=instance.network.inputs.list,
                 outputs=instance.network.outputs.list)>
                 
                 <
endif>
>>


printInstances(name, inputs, outputs) ::= <<
<instance.id> : entity work.<name>
  port map (
<if(!inputs.empty)
>
    <network.incomingMap.(instance).values: {connection | <printInputs(connection=connection, portPredMap=network.predecessorsMap.(instance), 
															srcVertex=network.sourceMap.(connection))>}; separator="\n">
<
endif><
if(!outputs.empty)
>
    <outgoingMap.(instance).values:
    	{connections| <connections:{connection | <printOutputs(connection=connection, portSuccMap=network.successorsMap.(instance), 
															tgtVertex=network.targetMap.(connection))>}; separator="\n">}; separator="\n">
<
endif>
    clock     =\> clock, 
    reset_n   =\> reset_n);
>>

/** Print input connection of an instance according to the maps:
 * 
 * connection: connection of the instance (e.g. a connection between two instance)
 * portPredMap: a map that associates each port of an instance to the predecessor of this port
 * srcVertex: contain the source of the connection (e.g. a port of the network)
 * 
 */ 
printInputs(connection, portPredMap, srcVertex) ::= <<
<if(portPredMap.(connection.target))
><if(portPredMap.(connection.target).broadcast)
><connection.target.name>_data     =\> <portPredMap.(connection.target).id>_fromBroad_data,
<else
><if(instance.broadcast && connection.target.type.bool)
><connection.target.name>_data(0)  =\> <instance.id>_<connection.target.name>_data,
<else
><connection.target.name>_data     =\> <instance.id>_<connection.target.name>_data,
<endif>
<endif>
<connection.target.name>_send     =\> <instance.id>_<connection.target.name>_send,
<connection.target.name>_ack      =\> <instance.id>_<connection.target.name>_ack,<
else
><if(instance.broadcast && connection.target.type.bool)
><connection.target.name>_data(0)  =\> <srcVertex.port.name>_data,
<else
><connection.target.name>_data     =\> <srcVertex.port.name>_data,
<endif>
<connection.target.name>_send     =\> <srcVertex.port.name>_send,
<connection.target.name>_ack      =\> <srcVertex.port.name>_ack,<
endif>
>>

/** Print output connections of an instance according to the maps:
 * 
 * connection: connection of the instance (e.g. a connection between two instance)
 * portSuccMap: a map that associates each port of an instance to the successors of this port
 * tgtVertex: target of the connection (e.g. a port of the network)
 * 
 */ 
printOutputs(connection, portSuccMap, tgtVertex) ::= <<
<if(first(portSuccMap.(connection.source)))
><if(connection.attributes)
><connection.source.name>_data     =\> <instance.id>_<connection.source.name>_data,
<connection.source.name>_send     =\> <instance.id>_<connection.source.name>_send,
<connection.source.name>_ack      =\> <instance.id>_<connection.source.name>_ack,<
else
><connection.source.name>_data     =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_data,
<connection.source.name>_send     =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_send,
<connection.source.name>_ack      =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_ack,<
endif><
else
><connection.source.name>_data     =\> <tgtVertex.port.name>_data,
<connection.source.name>_send     =\> <tgtVertex.port.name>_send,
<connection.source.name>_ack      =\> <tgtVertex.port.name>_ack,<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// print broadcasts instantiation
///////////////////////////////////////////////////////////////////////////////
printBroadcasts(outgoingMap) ::= <<
<outgoingMap.keys: {instance | <checkBroadcast(instance=instance)>}>
>>

checkBroadcast(instance) ::= <<
<if (instance.broadcast)
><printBroadcast(name=instance.id,
				 inputs=instance.broadcast.inputs.list,
                 outputs=instance.broadcast.outputs.list)><
endif>
>>

// Instanciate a broadcast if necessary
printBroadcast(name, inputs, outputs) ::= <<
broadcast_<name> : entity work.broadcast
  generic map (
    width =\> <if(instance.broadcast.type.bool)>1<else><instance.broadcast.type.size><endif>,
    size  =\> <instance.broadcast.numOutputs>)
  port map (
<if(!inputs.empty)>
    <network.incomingMap.(instance).values:{connection | <printInputs(connection=connection, portPredMap=network.predecessorsMap.(instance), 
															srcVertex=network.sourceMap.(connection))>}; separator="\n">
<endif>
<if(!outputs.empty)>
<if(last(outputs).type.bool)
>    output_data(0) =\> <name>_fromBroad_data,
<else
>    output_data    =\> <name>_fromBroad_data,
<endif>
    <outgoingMap.(instance).values: {connections | <printBroadcastOutputs(connections=connections, index=i0, network=network,
    								instance=instance, control="send")>}; separator="\n">	
    <outgoingMap.(instance).values: {connections | <printBroadcastOutputs(connections=connections, index=i0, network=network,
    								instance=instance, control="ack")>}; separator="\n">
<endif>
    clock         =\> clock,
    reset_n       =\> reset_n);
    --
    <outgoingMap.(instance).values: {connections|<connections:{connection | <printBroadToOut(tgtVertex=network.targetMap.(connection))>}>}>
>>

/** Print connection between broadcast and output
 * tgtVertex: target vertex of the connection (supposed to be a port)
 * 
 */
printBroadToOut(tgtVertex) ::= <<
<if(tgtVertex.port)
><tgtVertex.port.name>_data \<= <name>_fromBroad_data;<
endif>
>>

printBroadcastOutputs(connections, index, network , instance, control) ::= <<
<connections: { connection | <printBroadcastOutput( connection=connection, index=index, portSuccMap=network.successorsMap.(instance),
    			tgtVertex=network.targetMap.(connection), control=control)>}; separator="\n">		
>>

/** Print output connections of a broadcast to the maps:
 * 
 * connection: connection of the instance (e.g. a connection between two instances)
 * index: index of the output (e.g. 1, 2, 3, ...)
 * portSuccMap: a map that associates each port of an instance to the successors of this port
 * tgtVertex: target of the connection (e.g. a port of the network)
 * control: "send" or "ack"
 * 
 */
printBroadcastOutput(connection, index, portSuccMap, tgtVertex, control) ::= <<
<if(first(portSuccMap.(connection.source)))
><if(connection.attributes)
>output_<control>(<index>) =\> <instance.id>_<connection.source.name>_<control>,<
else
>output_<control>(<index>) =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_<control>,<
endif><
else
>output_<control>(<index>) =\> <tgtVertex.port.name>_<control>,<
endif>
>>

broadcastType(connection, name, direction) ::= <<
<if(connection.target.type.bool)
>signal <name>_<direction>_data : std_logic;<
else
>signal <name>_<direction>_data : std_logic_vector(<connection.target.type.size> -1 downto 0);<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// print the network
///////////////////////////////////////////////////////////////////////////////
network(network, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : Configuration: <network.name>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <network.name>.vhd
-- Author     : Orcc - VHDL
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;


------------------------------------------------------------------------------
entity <network.name> is
  generic (
  SIZE : integer := <options.fifoSize>);
  port (
    <printNetworkPorts(network)>
    clock    : in  std_logic;
    reset_n  : in  std_logic);  
end <network.name>;


------------------------------------------------------------------------------
architecture rtl_<network.name> of <network.name> is

  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  <tryPrintSignals(network.outgoingMap); separator="\n">
  ---------------------------------------------------------------------------

begin

  ---------------------------------------------------------------------------
  -- Actors and Networks instantiation 
  ---------------------------------------------------------------------------
  <PrintNetworksAndActors(network.outgoingMap)>
  ---------------------------------------------------------------------------
  -- Broadcast and FIFO instantiation 
  --------------------------------------------------------------------------- 
  <printBroadcasts(network.outgoingMap)>
  <assignFifos(network.connections)>
  ---------------------------------------------------------------------------

end architecture rtl_<network.name>;

>>
