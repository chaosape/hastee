

network(network, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : Network: <network.name>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <network.name>.vhd
-- Author     : Orcc - TTA
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------


------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;

library work;

------------------------------------------------------------------------------
entity top is
  port
    (
      hw_clk : in  std_logic;
      button : in  std_logic_vector(1 to 1);
      st2clk : out std_logic;
      leds   : out std_logic_vector(8 downto 0)
      );
end top;

------------------------------------------------------------------------------
architecture bdf_type of top is

  ---------------------------------------------------------------------------
  -- Components declaration
  ---------------------------------------------------------------------------
  component tta_fifo
    port(wrreq			: in  std_logic;
         reset_n		: in  std_logic;
         clk			: in  std_logic;
         rdreq			: in  std_logic;
         data			: in  std_logic_vector(31 downto 0);
         q				: out std_logic_vector(31 downto 0);
         status			: out std_logic_vector(8 downto 0)
         );
  end component;

  component mainpll
    port(inclk0			: in  std_logic;
         c0				: out std_logic
         );
  end component;

  component clock_div
    port(inclk0 		: in  std_logic;
         c0     		: out std_logic
         );
  end component;

  component button_debouncer
    generic (counter_max : integer;
             preset_val  : integer
             );
    port(clk      		: in  std_logic;
         rst_n    		: in  std_logic;
         data_in  		: in  std_logic;
         data_out 		: out std_logic
         );
  end component;
  
  <components(network)>
  ---------------------------------------------------------------------------
  
  
  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  -- System
  signal system_clock   : std_logic;
  signal system_vcc     : std_logic;
  signal system_reset_n : std_logic;
  
  <signals(network)>
  ---------------------------------------------------------------------------
  
begin

  ---------------------------------------------------------------------------
  -- System instantiation 
  --------------------------------------------------------------------------- 
  system_vcc \<= '1';

  mainpll_inst : mainpll
    port map(inclk0 =\> hw_clk,
             c0     =\> system_clock);

  st_clock_inst : clock_div
    port map(inclk0 =\> system_clock,
             c0     =\> st2clk);

  reset_debouncer : button_debouncer
    generic map(counter_max =\> 100000,
                preset_val  =\> 0
                )
    port map(clk      =\> system_clock,
             rst_n    =\> system_vcc,
             data_in  =\> button(1),
             data_out =\> system_reset_n);
  ---------------------------------------------------------------------------
  -- FIFOs instantiation 
  --------------------------------------------------------------------------- 
  <assignFifos(network.connections)>
  ---------------------------------------------------------------------------
  -- Actors instantiation 
  ---------------------------------------------------------------------------
  <assignInstances(network.instances)>
  ---------------------------------------------------------------------------


end bdf_type;

>>


///////////////////////////////////////////////////////////////////////////////
// Components
///////////////////////////////////////////////////////////////////////////////

components(network) ::= <<
<network.instances: component(); separator="\n\n">
>>

component(instance) ::= <<
<if(instance.actor)
>component processor_<instance.id>
  port(clk			: in  std_logic;
       <instance.actor.inputs: inputPort(); separator="\n">
       <instance.actor.outputs: outputPort(); separator="\n">
       reset_n		: in  std_logic
       );
end component;<
elseif(instance.broadcast)
>component processor_<instance.id>
  port(clk			: in  std_logic;
       data_0_in		: in  std_logic_vector(31 downto 0);
       status_0_in	: in  std_logic_vector(8 downto 0);
       ack_0_in		: out std_logic;
       <instance.broadcast.outputList: { index | <outputPortBroadcast(index)> }; separator="\n">
       reset_n		: in  std_logic
       );
end component;<
endif>
>>

inputPort(port) ::= <<
data_<indexPort(port)>_in		: in  std_logic_vector(31 downto 0);
status_<indexPort(port)>_in	: in  std_logic_vector(8 downto 0);
ack_<indexPort(port)>_in		: out std_logic;
>>

outputPort(port) ::= <<
data_<indexPort(port)>_out		: out std_logic_vector(31 downto 0);
status_<indexPort(port)>_out	: in  std_logic_vector(8 downto 0);
dv_<indexPort(port)>_out		: out std_logic;
>>

outputPortBroadcast(index) ::= <<
data_<index>_out		: out std_logic_vector(31 downto 0);
status_<index>_out	: in  std_logic_vector(8 downto 0);
dv_<index>_out		: out std_logic;
>>

indexPort(port) ::= <<
<instance.actor.templateData.portToIndexMap.(port)>
>>


///////////////////////////////////////////////////////////////////////////////
// Signals
///////////////////////////////////////////////////////////////////////////////

signals(network) ::= <<
<network.instances: { instance | <instanceSignals(instance, network.incomingMap.(instance), network.outgoingMap.(instance))> }; separator="\n\n">
>>

instanceSignals(instance, incomingMap, outgoingMap) ::= <<
-- Instance: <instance.id> 
<incomingMap.keys: { port | <inputPortSignals(port, incomingMap.(port))> }; separator="\n">
<outgoingMap.keys: { port | <outputPortSignals(port, first(outgoingMap.(port)))> }; separator="\n">
>>

inputPortSignals(port, connection) ::= <<
---- Input port: <port.name>
signal fifo_<indexFifo(connection)>_clk		: std_logic;
signal fifo_<indexFifo(connection)>_wrreq		: std_logic;
signal fifo_<indexFifo(connection)>_data		: std_logic_vector(31 downto 0);
>>

outputPortSignals(port, connection) ::= <<
---- Output port: <port.name>
signal fifo_<indexFifo(connection)>_rdreq		: std_logic;
signal fifo_<indexFifo(connection)>_q			: std_logic_vector(31 downto 0);
signal fifo_<indexFifo(connection)>_status		: std_logic_vector(8 downto 0);
>>

indexFifo(connection) ::= <<
<network.connectionMap.(connection)>
>>


///////////////////////////////////////////////////////////////////////////////
// Instantiation
///////////////////////////////////////////////////////////////////////////////

assignFifos(connections) ::= <<
<connections: assignFifo(); separator="\n\n">
>>

assignFifo(connection) ::= <<
fifo_<indexFifo(connection)> : tta_fifo
  port map(wrreq   =\> fifo_<indexFifo(connection)>_wrreq,
           reset_n =\> system_reset_n,
           clk     =\> system_clock,
           rdreq   =\> fifo_<indexFifo(connection)>_rdreq,
           data    =\> fifo_<indexFifo(connection)>_data,
           q       =\> fifo_<indexFifo(connection)>_q,
           status  =\> fifo_<indexFifo(connection)>_status);
>>

assignInstances(instances) ::= <<
<instances: assignInstance(); separator="\n\n">
>>

assignInstance(instance) ::= <<
<instance.id>_inst : processor_<instance.id>
  port map(clk          =\> system_clock,
           <assignPorts(instance)>
           reset_n      =\> system_reset_n);
>>

assignPorts(instance) ::= <<
<if(instance.actor)
><instance.actor.inputs: { input | <assignInputPort(port=input, index={<indexPort(input)>})> }; separator="\n">
<instance.actor.outputs: { output | <assignOutputPort(port=output, index={<indexPort(output)>})> }; separator="\n"><
elseif(instance.broadcast)
><assignInputPort(instance.broadcast.input, "0")>
<instance.broadcast.outputs.list: { output | <assignOutputPort(output, i0)> }; separator="\n"><
endif>
>>

assignInputPort(port, index) ::= <<
data_<index>_in    =\> fifo_<indexInputFifo(port)>_q,
status_<index>_in  =\> fifo_<indexInputFifo(port)>_status,
ack_<index>_in     =\> fifo_<indexInputFifo(port)>_rdreq,
>>

assignOutputPort(port, index) ::= <<
data_<index>_out   =\> fifo_<indexOutputFifo(port)>_data,
status_<index>_out =\> fifo_<indexOutputFifo(port)>_status,
dv_<index>_out     =\> fifo_<indexOutputFifo(port)>_wrreq,
>>

indexInputFifo(port) ::= <<
<indexFifo(network.incomingMap.(instance).(port))>
>>

indexOutputFifo(port) ::= <<
<indexFifo(first(network.outgoingMap.(instance).(port)))>
>>
