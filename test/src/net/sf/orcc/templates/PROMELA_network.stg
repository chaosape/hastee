GetInstanceId(instance) ::= <<
<if (instance.broadcast)>bcast_<endif><instance.id>
>>

declareBroadcast(instance) ::= <<
<if (instance.broadcast)
>
proctype <GetInstanceId(instance)> (){
	<instance.broadcast.type> temp = 0;
	do
	::	atomic{ nempty(chan_<GetInstanceId(instance)>_input) -\> 
			chan_<GetInstanceId(instance)>_input?\<temp\>;
			<instance.broadcast.outputList: { n | chan_<GetInstanceId(instance)>_output_<n>!temp;}; separator="\n">
			<instance.broadcast.outputList: { n | nfull(chan_<GetInstanceId(instance)>_output_<n>);}; separator="\n">
			chan_<GetInstanceId(instance)>_input?temp;
		}
		
	od

}<
endif>

>>

declareBroadcasts(instances) ::= <<
<instances: declareBroadcast()>
>>

///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(count, type, edge) ::= <<
chan chan_<count> = [<if(edge.size)><edge.size><else>SIZE<endif>] of {<type>};
>>

tryAllocateFifo(edge, src, tgt) ::= <<
<if (src.instance)>
<allocateFifoType(
  count=network.connectionMap.(edge),
  type=edge.source.type,
  edge=edge)><else>
<allocateFifoType(
  count=network.connectionMap.(edge),
  type=edge.target.type,
  edge=edge)><endif>
>>


allocateFifo(edge) ::= <<
<tryAllocateFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

allocateFifos(edges) ::= <<
<edges: allocateFifo()>
>>
///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifoSrc(source, sourcePort, count) ::= <<
#define chan_<GetInstanceId(source)>_<sourcePort.name> chan_<count>
>>

doAssignFifoTgt(target, targetPort, count) ::= <<
#define chan_<GetInstanceId(target)>_<targetPort.name> chan_<count>
>>

tryAssignFifo(edge, src, tgt) ::= <<
<if (src.instance)>
<doAssignFifoSrc(
  source=src.instance, sourcePort=edge.source,
  count=network.connectionMap.(edge))><endif>
<if (tgt.instance)>
<doAssignFifoTgt(
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))><endif>
>>

assignFifo(edge) ::= <<
<tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

assignFifos(edges) ::= <<
<edges: assignFifo()>
>>


///////////////////////////////////////////////////////////////////////////////
// print network

network(network, options) ::= <<
// Generated from "<network.name>"

#define uint int
#define SIZE 1

// FIFO allocation
<allocateFifos(network.connections)>

// FIFO assignment
<assignFifos(network.connections)>

// Declear Broadcasts
<declareBroadcasts(network.instances)>

// Include the actors
<network.Instances: {instance | <if (!instance.broadcast)>#include "<instance.id>.pml"<endif>}; separator="\n">

init {
	/*Inputs here*/

	/*Start processes*/
	atomic{
		<network.Instances: {instance | run <GetInstanceId(instance)>(/*init_state*/);}; separator="\n">
	}	
}

>>

