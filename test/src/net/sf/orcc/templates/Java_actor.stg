import "net/sf/orcc/templates/C_actor.stg"

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<
private Fifo_<port.type> fifo_<port.name>;

>>

setFifo(port) ::= <<
if ("<port.name>".equals(portName)) {
	fifo_<port.name> = (Fifo_<port.type>) fifo;
} else 
>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(values) ::= <<
<values : {value | [<value>]} >
>>

// the dimensions of a list: [][]...[]
// does not output anything if <value> is empty
// differs from inherited listSize because this one does not print any size
// information.
listDim(value) ::= <<
<value : {val | []} >
>>

// a variable definition
// called by "function parameter", or "state variable with value"
variableDeclaration(variable) ::= <<
<variable.type><listDim(variable.type.dimensions)> <variable.name>
>>

// a variable definition with initialization
// called by "local variable", or "state variable with no value"
variableDeclarationInit(variable) ::= <<
<if(variable.port)>
<variable.type>[] <variable><
else
><variable.type><listDim(variable.type.dimensions)> <variable><
if(variable.type.dimensions)
> = new <variable.type><listSize(variable.type.dimensions)><
endif
><endif> >>

parameter(parameter) ::= <<
private <variableDeclarationInit(parameter)>;

>>

parameters(parameters) ::= <<
<parameters: parameter()>
>>

declareParameters(parameters) ::= <<
<parameters: variableDeclaration(); wrap, separator=", ">
>>

setParameter(parameter) ::= <<
this.<parameter> = <parameter>;

>>

setParameters(parameters) ::= <<
<parameters: setParameter()>
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<(constant.class.simpleName)(constant)>
>>

BoolExpr(expr) ::= <<
<expr.value>
>>

BinaryExpr(expr) ::= <<
(<expr>)
>>

VarExpr(expr) ::= <<
<expr>
>>

// a state variable
stateVar(variable) ::= <<
<if(variable.initialized)>
private <variableDeclaration(variable)> = <Constant(variable.initialValue)>;
<else>
private <variableDeclarationInit(variable)>;
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printParameter(parameter) ::= <<
<if (parameter.stringExpr)
>"<parameter>"<
else
><Constant(parameter)><
endif>
>>

printCall(call) ::= <<

<if(call.print)>System.out.print(<call.parameters: printParameter(); separator=" + ">);<
else
><if(call.target)><call.target> = <endif><call.procedure>(<call.parameters; separator=", ">);<
endif>
>>

printLoad(load) ::= <<

<if (load.source.variable.port && !load.indexes.empty)
><load.target> = <load.source>[<load.source>_Index + <first(load.indexes)>]<rest(load.indexes) : {index | [<index>]}>;<
else
><load.target> = <load.source><load.indexes : {index | [<index>]}>;<endif>
>>

// peek instruction
printPeek(peek) ::= <<
<printRead(peek)>
>>

// read instruction
printRead(read) ::= <<

<if (read.target)
>int <read.port>_Index = fifo_<read.port>.getReadIndex(<read.numTokens>);
<read.target> = fifo_<read.port>.getReadArray(<read.numTokens>);<
else
>fifo_<read.port>.getReadIndex(<read.numTokens>);
fifo_<read.port>.getReadArray(<read.numTokens>);<endif>
>>

printReadEnd(readEnd) ::= <<

fifo_<readEnd.port>.readEnd(<readEnd.numTokens>);
>>

printStore(store) ::= <<

<if (store.target.port && !store.indexes.empty)
><store.target>[<store.target>_Index + <first(store.indexes)>]<rest(store.indexes) : {index | [<index>]}> = <store.value>;<
else
><store.target><store.indexes : {index | [<index>]}> = <store.value>;<endif>
>>

// write instruction
printWrite(write) ::= <<

<write.target> = fifo_<write.port>.getWriteArray(<write.numTokens>);
int <write.port>_Index = fifo_<write.port>.getWriteIndex(<write.numTokens>);
>>

printWriteEnd(writeEnd) ::= <<

fifo_<writeEnd.port>.writeEnd(<writeEnd.numTokens>, <writeEnd.target>);
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure and actions
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<
<if(!procedure.native)>

private <procedure.returnType> <procedure>(<procedure.parameters.list: {parameter | <variableDeclaration(parameter)>}; wrap, anchor, separator=", ">) {
<if(procedure.locals.list)>
	<procedure.locals.list: {local | <variableDeclarationInit(local)>;<\n>}>
<endif>
	<printNodes(procedure.nodes)>
}

<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
<pattern.keys:{port|fifo_<port>.hasRoom(<pattern.(port)>)}; separator=" && ">
>>

checkInputPatternPort(port) ::= <<
fifo_<port>.hasTokens(<pattern.(port)>)
>>

checkInputPattern(pattern) ::= <<
<pattern.keys: { port | <checkInputPatternPort(port)> && }>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
<action>();
res = true;
i++;
>>

actionTest(action) ::= <<
if (<checkInputPattern(action.inputPattern)>isSchedulable_<action>()) {
	<if(action.outputPattern)>
	if (<outputPattern(action.outputPattern)>) {
		<actionCall(action)>
	}
	<else>
	<actionCall(action)>
	<endif>
}>>

schedulingTest(actions) ::= <<
<actions: actionTest(); separator=" else ">
>>

scheduler(actions) ::= <<
@Override
public int schedule() {
	boolean res = true;
	int i = 0;

	while (res) {
		res = false;
		<if(actions)>
		<schedulingTest(actions)>
		<endif>
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
<nextState.action>();
_FSM_state = States.s_<nextState.targetState>;
res = true;
>>

actionTestState(nextState) ::= <<
if (<checkInputPattern(nextState.action.inputPattern)>isSchedulable_<nextState.action>()) {
	<if(nextState.action.outputPattern)>
	if (<outputPattern(nextState.action.outputPattern)>) {
		<actionCallState(nextState)>
	}
	<else>
	<actionCallState(nextState)>
	<endif>
}>>

schedulingTestState(nextStates) ::= <<
<nextStates: actionTestState(); separator=" else ">
>>

stateScheduler(transition) ::= <<
private boolean stateScheduler_<transition.sourceState>() {
	boolean res = false;
	<schedulingTestState(transition.nextStateInfo)>
	return res;
}

>>

transition(transition) ::= <<
case s_<transition.sourceState>:
	res = stateScheduler_<transition.sourceState>();
	if (res) {
		i++;
	}
	break;
>>

switch(transitions) ::= <<
switch (_FSM_state) {
<transitions: transition()>
default:
	System.out.println("unknown state: %s\n" + _FSM_state);
	break;
}
>>

schedulerFSM(actions, fsm) ::= <<
private enum States {
	<fsm.states : {state | s_<state>}; separator=",\n">
};

private States _FSM_state = States.s_<fsm.initialState>;

<if(actions)>
private boolean outside_FSM_scheduler() {
	boolean res = false;
	int i = 0;
	<schedulingTest(actions)>
	return res;
}


<endif>
<fsm.transitions: stateScheduler(); separator="\n">
@Override
public int schedule() {
	boolean res = true;
	int i = 0;

	while (res) {
		res = false;
		<if(actions)>
		if (outside_FSM_scheduler()) {
			res = true;
			i++;
		} else {
			<switch(fsm.transitions)>
		}
		<else>
		<switch(fsm.transitions)>
		<endif>
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
/**
 * Generated from "<actor.name>"
 */
package net.sf.orcc.generated.<actor.package>;

import net.sf.orcc.runtime.*;
import net.sf.orcc.runtime.actors.IActor;

public class Actor_<actor.simpleName> implements IActor {


	// Input FIFOs
	<actor.inputs.list: fifo()>
	// Output FIFOs
	<actor.outputs.list: fifo()>
	// Parameters of the actor
	<parameters(actor.parameters.list)>
	// State variables of the actor
	<actor.stateVars.list: stateVar()>
	
	public Actor_<actor.simpleName>(<declareParameters(actor.parameters.list)>) {
		<setParameters(actor.parameters.list)>
	}
	
	// Functions/procedures
	<actor.procs.list: procedure()>
	// Actions
	<actor.actions: action()>
<if(actor.initializes)>
	// Initializes
	<actor.initializes: action()>
<endif>
	@Override
	public void initialize() {
<if(actor.initializes)>
		boolean res = false;
		int i = 0;
		if (res){
		}

		<schedulingTest(actor.initializes)>
<endif>
	}

	@Override
	public void setFifo(String portName, Fifo fifo) {
		<actor.inputs.list: setFifo()><actor.outputs.list: setFifo()>{
			String msg = "unknown port \"" + portName + "\"";
			throw new IllegalArgumentException(msg);
		}
	}

	// Action scheduler
<if(actor.actionScheduler.fsm)>
	<schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)>
<else>
	<scheduler(actor.actionScheduler.actions)>
<endif>

}

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
<procedure(action.body)><procedure(action.scheduler)>
>>


