import "net/sf/orcc/templates/C_actor.stg"
import "net/sf/orcc/templates/C_actor.stg"

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(values) ::= <<
<values : {value | [<value>]} >
>>

varDecl(variable) ::= <<
<variable.type> <variable.indexedName><listSize(variable.type.dimensions)>
>>

varDef(variable) ::= <<
<if (variable.initialized)>
<if (variable.type.dimensions)>
<variable.type> <variable.indexedName>_tmp<listSize(variable.type.dimensions)> = <Constant(variable.initialValue)>;
memcpy(<variable.indexedName>, <variable.indexedName>_tmp, <variable.type.dimensions; separator=" * "> * sizeof(<variable.type>));
<else>
<variable.indexedName> = <Constant(variable.initialValue)>;
<endif>
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<if (constant.booleanExpr)><printBool(constant)><
elseif (constant.intExpr)><printInt(constant)><
elseif (constant.listExpr)><printList(constant)><
elseif (constant.stringExpr)><printString(constant)><
endif>
>>


printBool(constant) ::= <<
<if (constant.value)>true<else>false<endif>
>>

printInt(number) ::= <<
<number><if (number.long)>L<endif>
>>

// the values of a list: {val1, val2, ..., valn}
printList(constant) ::= <<
{<constant.value: Constant(); wrap, separator=", ">}
>>

printString(constant) ::= <<
"<constant>"
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<

<assign.target.variable.indexedName> = <assign.value>;
>>

printParameter(parameter)::= <<
<if (parameter.stringExpr)
>"<parameter>"<
else
><parameter><
endif>
>>

printCall(call) ::= <<

<if(call.print)>std::cout \<\< <call.parameters: printParameter(); separator=" << ">;<
else
><if(call.target)><call.target.variable.indexedName> = <endif><call.procedure.name>(<call.parameters; separator=", ">);<
endif>
>>

printLoad(load) ::= <<

<load.target.variable.indexedName> = <load.source.variable.name><load.indexes : {index | [<index>]}>;
>>

printPeek(port, variable, numTokens) ::= <<

m_poTabIn[<actor.simpleName>_<port.name>]-\>peek(<variable.name>, <numTokens>);<\n>
>>

printRead(port, variable, numTokens) ::= <<

<if(variable)>
m_poTabIn[<actor.simpleName>_<port.name>]-\>get(<variable.name>, <numTokens>);
m_avails[<actor.simpleName>_<port.name>] -= <numTokens>;
<else>
m_poTabIn[<actor.simpleName>_<port.name>]-\>skip(<numTokens>);<\n>
m_avails[<actor.simpleName>_<port.name>] -= <numTokens>;
<endif>
>>

printReturn(return) ::= <<

<if(return.value)>
return <return.value>;
<endif>
>>

printStore(store) ::= <<

<store.target.variable.name><store.indexes : {index | [<index>]}> = <store.value>;
>>

printWrite(port, variable, numTokens) ::= <<

m_poTabOut[<actor.simpleName>_<port.name>]-\>put(<variable.name>, <numTokens>);
m_rooms[<actor.simpleName>_<port.name>] -= <numTokens>;
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
endif>}>
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// block node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if (<ifNode.condition>) {
	<printNodes(ifNode.thenNodes)>
}<if(ifNode.elseNodes)> else {
	<printNodes(ifNode.elseNodes)>
}<endif>
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

while (<whileNode.condition>) {
	<printNodes(whileNode.nodes)>
}
<printBlockNode(whileNode.joinNode)>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<
<if(!procedure.native)>
<procedure.returnType> <actor.simpleName>::<procedure.name>(<procedure.parameters: varDecl(); wrap, anchor, separator=", ">)
{
<if(procedure.locals)>
	<procedure.locals: {local | <varDecl(local)>;<\n>}>

<endif>
	<printNodes(procedure.nodes)>
}
<else>
extern <procedure.returnType> <procedure.name>(<procedure.parameters: varDecl(); wrap, anchor, separator=", ">);
<endif>

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////


printActionBody(procedure) ::= <<
<if(!procedure.native)
><procedure.returnType> <actor.simpleName>::<procedure.name>(<procedure.parameters: {param | <varDecl(param)>}; wrap, anchor, separator=", ">)
{
	<action.inputPattern.ports : {port | <varDecl(action.inputPattern.portToVarMap.(port))>;}>
	<action.outputPattern.ports : {port | <varDecl(action.outputPattern.portToVarMap.(port))>;}>
	<action.inputPattern.ports : {port | <printRead(port=port, variable=action.inputPattern.portToVarMap.(port), numTokens=action.inputPattern.numTokensMap.(port))>}>

<if(procedure.locals)>
	<procedure.locals: {local | <varDecl(local)>;<\n>}>
<endif>
	<printNodes(procedure.nodes)>
	<action.outputPattern.ports : {port | <printWrite(port=port, variable=action.outputPattern.portToVarMap.(port), numTokens=action.outputPattern.numTokensMap.(port))>}>
}<
endif>
>>

printActionScheduler(procedure) ::= <<
<procedure.returnType> <actor.simpleName>::<procedure.name>(<procedure.parameters: {param | <varDecl(param)>}; wrap, anchor, separator=", ">)
{
	<action.inputPattern.ports : {port | <if(action.peekPattern.portToVarMap.(port))><varDecl(action.peekPattern.portToVarMap.(port))>;<endif>}>
	<action.inputPattern.ports : {port | <if(action.peekPattern.portToVarMap.(port))><printPeek(port=port, variable=action.peekPattern.portToVarMap.(port), numTokens=action.peekPattern.numTokensMap.(port))><endif>}>

<if(procedure.locals)>
	<procedure.locals: {local | <varDecl(local)>;<\n>}>
<endif>
	<printNodes(procedure.nodes)>
}
>>

action(action) ::= <<

<printActionBody(action.body)>

<printActionScheduler(action.scheduler)>

>>

actionTrace(action) ::= <<
#ifdef __TRACE_CAPTURE__
g_oTracer.captureAction(this, "<action.name>");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
<pattern.ports:{port | hasRooms(<actor.simpleName>_<port.name>, <pattern.numTokensMap.(port)>)}; wrap, anchor, separator=" && ">
>>

inputPattern(pattern) ::= <<
<pattern.ports:{port | hasTokens(<actor.simpleName>_<port.name>, <pattern.numTokensMap.(port)>) && }>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
<actionTrace(action)>
this-\><action.body.name>();
res = true;
i++;
>>

actionTest(action) ::= <<
if(<inputPattern(action.inputPattern)>isSchedulable_<action.name>())
{
	<if(!action.outputPattern.empty)>
	if(<outputPattern(pattern=action.outputPattern)>)
	{
		<actionCall(action)>
	}
	<else>
	<actionCall(action)>
	<endif>
}
>>

schedulingTest(actions) ::= <<
<actionTest(first(actions))>
<if(rest(actions))>
else
{
	<schedulingTest(rest(actions))>
}
<endif>
>>

scheduler(actions) ::= <<
int <actor.simpleName>::schedule()
{
	getFifoStatus();

	bool res = true;
	int i = 0;
  
	while (res) 
	{
		res = false;
		<if(actions)>
		<schedulingTest(actions)>
		<endif>
	}
	
	updateFifoStatus();
	
	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
<actionTrace(nextState.action)>
this-\><nextState.action.name>();
_FSM_state = state_<nextState.state.name>;
res = true;
>>

actionTestState(nextState) ::= <<
if(<inputPattern(nextState.action.inputPattern)>isSchedulable_<nextState.action.name>())
{
	<if(!nextState.action.outputPattern.empty)>
	if(<outputPattern(nextState.action.outputPattern)>)
	{
		<actionCallState(nextState)>
	}
	<else>
	<actionCallState(nextState)>
	<endif>
}>>

schedulingTestState(nextStates) ::= <<
<actionTestState(first(nextStates))>
<if(rest(nextStates))>
else
{
	<schedulingTestState(rest(nextStates))>
}
<endif>

>>

stateScheduler(transitions) ::= <<
bool <actor.simpleName>::<transitions.sourceState.name>_state_scheduler()
{
<if(transitions.list.empty)>
	std::cout \<\< "stuck in dead end state! <transitions.sourceState.name> in the actor <actor.name>" \<\< std::endl;
	return false;
<else>

	bool res = false;
	<schedulingTestState(nextStates=transitions.list)>
	return res;
<endif>
}

>>

switch(transitions) ::= <<
switch (_FSM_state)
{
<transitions: {transition | case state_<transition.sourceState.name>:
	res = <transition.sourceState.name>_state_scheduler();
	break;
}>
default:
	std::cout \<\< "unknown state: " \<\< _FSM_state \<\< std::endl;
	break;
}
if (res){i++;}
>>

schedulerFSM(actions, fsm) ::= <<
<if(actions)>
bool <actor.simpleName>::outside_FSM_scheduler()
{
	bool res = false;
	int i = 0;
	<schedulingTest(actions)>
	return res;
}


<endif>
<fsm.transitions: stateScheduler(); separator="\n">
int <actor.simpleName>::schedule()
{
	getFifoStatus();

	bool res = true;
	int i = 0;

	while (res)
	{
		res = false;
		
		<if(actions)>
		if(outside_FSM_scheduler())
		{
			res = true;
			i++;
		}
		else
		{
			<switch(fsm.transitions)>
		}
		<else>
		<switch(fsm.transitions)>
		<endif>
	}
	
	updateFifoStatus();
	
	return i;
}

>>

constructor(parameters, stateVars) ::= <<
<if (actor.parameters)>
<actor.simpleName>::<actor.simpleName>(const char* instanceName, <if(parameters)><parameters: {param | <param.type> <param.indexedName>}; separator=", ">,<endif> AKA_PROFILING_MODE eProfilingMode)
<else>
<actor.simpleName>::<actor.simpleName>(const char* instanceName, AKA_PROFILING_MODE eProfilingMode)
<endif>
:
ActorAKA("<actor.simpleName>", instanceName, <length(actor.inputs)>, <length(actor.outputs)>, eProfilingMode)
{
	<parameters: {param | this-\><param.indexedName> = <param.indexedName>;}; separator="\n">

	<stateVars : varDef()>
<if(actor.fsm)>
	_FSM_state = state_<actor.fsm.initialState.name>;
<endif>
}

>>

destructor(stateVars) ::= <<
<actor.simpleName>::~<actor.simpleName>()
{
}

>>


///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
#include \<iostream\>
#include \<string.h\>

#include "<actor.simpleName>.h"
<if (!actor.packageAsList.empty)>
using namespace <actor.packageAsList; separator="::">;
<endif>
#ifdef __TRACE_CAPTURE__
extern TraceAka g_oTracer;
#endif

const char* <actor.simpleName>::className = "<actor.simpleName>";

<constructor(parameters=actor.parameters, stateVars=actor.stateVars)>

<destructor(stateVars=actor.stateVars)>

void <actor.simpleName>::initializeActor()
{
}


////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
<actor.procs: procedure()>
////////////////////////////////////////////////////////////////////////////////
// Actions
<actor.actions: action()>
<if(actor.initializes)>
////////////////////////////////////////////////////////////////////////////////
// Initializes
<actor.initializes: action()>
void <actor.simpleName>::initialize()
{
	bool res = true;
	int i = 0;

	<if(actor.initializes)>
	<schedulingTest(actor.initializes)>
	<endif>
}

<endif>
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
<if(actor.fsm)>
<schedulerFSM(actions=actor.actionsOutsideFsm, fsm=actor.fsm)>
<else>
<scheduler(actions=actor.actionsOutsideFsm)>
<endif>


>>
