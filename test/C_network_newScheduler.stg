///////////////////////////////////////////////////////////////////////////////
// Declare predecessors and successors

Neighbor(port) ::= <<
&<GetInstanceId(map.(port))>
>>

Neighbors(map, ports) ::= <<
<ports: Neighbor(); separator=", ">
>>

goDeclarePredSucc(inputs, outputs) ::= <<
<if(!inputs.empty)
>struct actor_s *<GetInstanceId(instance)>_predecessors[] = {<Neighbors(map=network.predecessorsMap.(instance), ports=inputs)>};
<endif><
if(!outputs.empty)
>struct actor_s *<GetInstanceId(instance)>_successors[] = {<Neighbors(map=network.successorsMap.(instance), ports=outputs)>};
<endif>
>>

goDeclarePredsSuccs(instance, incoming, outgoing) ::= <<
<if (instance.actor)
><goDeclarePredSucc(inputs=instance.actor.inputs.list,
                    outputs=instance.actor.outputs.list)><
elseif (instance.broadcast)
><goDeclarePredSucc(inputs=instance.broadcast.inputs.list,
                   outputs=instance.broadcast.outputs.list)><
endif>
>>

declarePredsSuccs(instances) ::= <<
<instances:
  {inst | <goDeclarePredsSuccs(instance=inst,
    incoming=network.incomingMap.(inst),
    outgoing=network.outgoingMap.(inst))>}>
>>

///////////////////////////////////////////////////////////////////////////////
// Define actors

fillActorStruct(instance) ::= <<

struct actor_s <GetInstanceId(instance)> = {"<GetInstanceId(instance)>", <GetInstanceId(instance)>_scheduler, <
NumInputs(instance)>, <NumOutputs(instance)>, <
if(instance.actor.inputs.list.empty)>NULL<else><GetInstanceId(instance)>_predecessors<endif>, <
if(instance.actor.outputs.list.empty)>NULL<else><GetInstanceId(instance)>_successors<endif>};
>>

printSchedulers(isPointer) ::= <<

struct actor_s *my_actor;
struct schedinfo_s si;
while (1) {
	my_actor = sched_get_next_schedulable(sched);
	if(my_actor != NULL){
		si.num_firings = 0;
		my_actor-\>sched_func(&si);
#ifdef PRINT_FIRINGS
		printf("%5i\t%s\t%s\n", si.num_firings, si.reason == starved ? "starved" : "full", my_actor-\>name);
#endif
		if (si.reason == full) {
			sched_add_successors(sched, my_actor, si.ports);
		} else if (si.reason == starved) {
			sched_add_predecessors(sched, my_actor, si.ports);
		}
	}
}
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network, options) ::= <<
// Generated from "<network.name>"

#include \<locale.h\>
#include \<stdio.h\>
#include \<stdlib.h\>

<if (options.needPthreads)>
#ifndef _WIN32
#define __USE_GNU
#endif
<endif>

#include "orcc.h"
#include "orcc_fifo.h"
#include "orcc_scheduler.h"
#include "orcc_util.h"
<if (options.needPthreads)>
#include "orcc_thread.h"
<endif>

#define SIZE <fifoSize>

////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
<allocateFifos(network.connections)>
////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
<assignFifos(network.connections)>
////////////////////////////////////////////////////////////////////////////////
<declareBroadcasts(network.instances)>
////////////////////////////////////////////////////////////////////////////////
// Action schedulers
<declareInitializes(network.instances)>
<declareSchedulers(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Declaration of a struct actor for each actor

<declareActors(network.instances)>
////////////////////////////////////////////////////////////////////////////////
// Declaration of the predecessors and successors of each actor

<declarePredsSuccs(network.instances)>
////////////////////////////////////////////////////////////////////////////////
// Declaration of the actors array

<fillActorsStructs(network.instances)>

<if(options.needPthreads)>

<options.threads.keys: {th | <declareActorsArray(thread=th,instances=options.threads.(th))>}; separator="\n">

<printThread()>

static void scheduler() {
	cpu_set_t cpuset;
	thread_struct <options.threads.keys: {th | thread_<th>}; separator=", ">;
	thread_id_struct <options.threads.keys: {th | thread_id_<th>}; separator=", ">;
	struct scheduler_s <options.threads.keys: {th | sched_<th>}; separator=", ">;
	
	<printInitializes(network.instances)>
	
	<options.threads.keys: {th | sched_init(&sched_<th>, sizeof(actors_<th>) / sizeof(actors_<th>[0]), actors_<th>, NULL);}; separator="\n">
	
	sched_add_schedulable(source.sched, &source);
	
	<options.threads.keys: {th | threadCreate(thread_<th>, thread_scheduler, sched_<th>, thread_id_<th>);}; separator="\n">

	clear_cpu_set(cpuset);
	<options.threads.keys: {th | set_affinity(cpuset, <i0>, thread_<th>);}; separator="\n">

	<options.threads.keys: {th | threadJoin(thread_<th>);}; separator="\n">
}

<else>

<declareActorsArray(instances=network.instances)>
////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

// Uncomment to print firings
// #define PRINT_FIRINGS

static void scheduler() {
	struct scheduler_s my_scheduler;
	struct actor_s *my_actor;
	struct schedinfo_s si;
	int iterations = 0;

	// initializes the actors that need it
	<printInitializes(network.instances)>
	// initialize scheduler
	sched_init(&my_scheduler, sizeof(actors) / sizeof(actors[0]), actors, NULL);

	sched_add_schedulable(&my_scheduler, &source);
	my_actor = sched_get_next_schedulable(&my_scheduler);
	while (my_actor != NULL) {
		iterations++;
		si.num_firings = 0;
		my_actor-\>sched_func(&si);
#ifdef PRINT_FIRINGS
		printf("%5i\t%s\t%s\n", si.num_firings, si.reason == starved ? "starved" : "full", my_actor-\>name);
#endif
		if (si.reason == full) {
			sched_add_successors(&my_scheduler, my_actor, si.ports);
		} else if (si.reason == starved) {
			sched_add_predecessors(&my_scheduler, my_actor, si.ports);
		}

		my_actor = sched_get_next_schedulable(&my_scheduler);

		if (iterations % 1000 == 0) {
			//printf("\n");
		}
	}
}

<endif>

////////////////////////////////////////////////////////////////////////////////

<printMain()>

>>

