///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(values) ::= <<
<values : {value | [<value>]} >
>>

// the values of a list: {val1, val2, ..., valn}
listValue(values) ::= <<
{<values; wrap, separator=", ">}
>>

variableDeclaration(variable) ::= <<
<variable.type> <variable><listSize(variable.type.dimensions)>
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<(constant.class.simpleName)(constant)>
>>


BoolExpr(constant) ::= <<
<if (constant.value)>true<else>false<endif>
>>

IntExpr(number) ::= <<
<number><if (number.long)>L<endif>
>>

// the values of a list: {val1, val2, ..., valn}
ListExpr(constant) ::= <<
{<constant.value: Constant(); wrap, separator=", ">}
>>

StringExpr(constant) ::= <<
"<constant>"
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

defineConstantVars(variables) ::= <<
namespace
{
	<variables:defineConstantVar()>}
>>

defineConstantVar(variable) ::= <<
<if(!variable.assignable)>
const <variableDeclaration(variable)> = <Constant(variable.initialValue)>;<\n><endif>
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
StateVarAllocation(variable) ::= <<
<if(variable.assignable)>
<if (variable.type.dimensions)>
<variable>(new <variable.type><listSize(variable.type.dimensions)>),
<else>
<if (variable.initialized)>
<variable>(<Constant(variable.initialValue)>),
<endif>
<endif>
<endif>

>>


///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
StateVarDestruction(variable) ::= <<
<if(variable.assignable)
><if (variable.type.dimensions)
>delete [] <variable>;<
endif><
endif>

>>


///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
ListStateVarInitialization(variable) ::= <<
<if(variable.assignable)>
<if (variable.type.dimensions)>
<if (variable.initialized)>
const <variable.type> tmp_<variable>[<variable.type.dimensions>] = <Constant(variable.initialValue)>;
memcpy(<variable>, tmp_<variable>, <variable.type.dimensions> * sizeof(<variable.type>));
<endif>
<endif>
<endif>

>>
///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<

<assign.target> = <assign.value>;
>>

PrintParameter(parameter)::= <<
<if (parameter.stringExpr)
>"<parameter>"<
else
><parameter><
endif>
>>

Call(call) ::= <<

<if(call.print)>std::cout \<\< <call.parameters: PrintParameter(); separator=" << ">;<
else
><if(call.target)><call.target> = <endif><call.procedure>(<call.parameters; separator=", ">);<
endif>
>>

Decrement(decrement) ::= <<

<decrement.target>--;
>>

Increment(increment) ::= <<

<increment.target>++;
>>

Load(load) ::= <<

<load.target> = <load.source><load.indexes : {index | [<index>]}>;
>>

Peek(peek) ::= <<

<if(peek.unit)>
m_poTabIn[<actor.simpleName>_<peek.port>]-\>peek(<peek.target>);<\n>
<else>
m_poTabIn[<actor.simpleName>_<peek.port>]-\>peek(<peek.target>, <peek.numTokens>);<\n>
<endif>
>>

Read(read) ::= <<

<if (read.target)>
<if(read.unit)>
m_poTabIn[<actor.simpleName>_<read.port>]-\>get(<read.target>);$\n$
m_arrAvailStatus[<actor.simpleName>_<read.port>] --;
<else>
m_poTabIn[<actor.simpleName>_<read.port>]-\>get(<read.target>, <read.numTokens>);<\n>
m_arrAvailStatus[<actor.simpleName>_<read.port>] -= <read.numTokens>;
<endif>
<else>
m_poTabIn[<actor.simpleName>_<read.port>]-\>skip(<read.numTokens>);<\n>
m_arrAvailStatus[<actor.simpleName>_<read.port>] -= <read.numTokens>;
<endif>
>>

ReadEnd(readEnd) ::= <<
>>

Return(return) ::= <<

<if(return.value)>
return <return.value>;
<endif>
>>

SelfAssignment(selfAssign) ::= <<

<selfAssign.target> <selfAssign.op.text>= <selfAssign.value>;
>>

Store(store) ::= <<

<store.target><store.indexes : {index | [<index>]}> = <store.value>;
>>

Write(write) ::= <<

<if(write.unit)>
m_poTabOut[<actor.simpleName>_<write.port>]-\>put(<write.target>);<\n>
m_arrRoomStatus[<actor.simpleName>_<write.port>]--;
<else>
m_poTabOut[<actor.simpleName>_<write.port>]-\>put(<write.target>, <write.numTokens>);<\n>
m_arrRoomStatus[<actor.simpleName>_<write.port>] -= <write.numTokens>;

<endif>

>>

WriteEnd(writeEnd) ::= <<

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
<instructions: {instruction | <(instruction.class.simpleName)(instruction)>}>
>>

nodes(nodes) ::= <<
<nodes: {node | <(node.class.simpleName)(node)>}>
>>

// if node
BlockNode(blockNode) ::= <<

<instructions(blockNode.instructions)>
>>

// if node
IfNode(ifNode) ::= <<

if (<ifNode.value>) {
	<nodes(ifNode.thenNodes)>
}<if(ifNode.elseNodes)> else {
	<nodes(ifNode.elseNodes)>
}<endif>
<BlockNode(ifNode.joinNode)>
>>

// while node
WhileNode(whileNode) ::= <<

while (<whileNode.value>) {
	<nodes(whileNode.nodes)>
}
<BlockNode(whileNode.joinNode)>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

<procedure.returnType> <actor.simpleName>::<procedure>(<procedure.parameters.list: {param | <variableDeclaration(param)>}; wrap, anchor, separator=", ">)
{
<if(procedure.locals.list)>
	<procedure.locals.list: {local | <variableDeclaration(local)>;<\n>}>

<endif>
	<procedure.nodes: {node | <(node.class.simpleName)(node)>}>}

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
<procedure(action.body)><procedure(action.scheduler)>
>>

actionTrace(action) ::= <<
#ifdef __TRACE_CAPTURE__
g_oTracer.captureAction(this, "<action.name>");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
<pattern.keys:{port | hasRooms(<actor.simpleName>_<port>, <pattern.(port)>)}; wrap, anchor, separator=" && ">
>>

inputPattern(pattern) ::= <<
<pattern.keys:{port | hasTokens(<actor.simpleName>_<port>, <pattern.(port)>) && }>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
<actionTrace(action)>
<action.body>();
res = true;
i++;
>>

actionTest(action) ::= <<
if(<inputPattern(action.inputPattern)>isSchedulable_<action>())
{
	<if(action.outputPattern)>
	if(<outputPattern(pattern=action.outputPattern)>)
	{
		<actionCall(action)>
	}
	<else>
	<actionCall(action)>
	<endif>
}
>>

schedulingTest(actions) ::= <<
<actions: actionTest(); separator="\nelse ">
>>

scheduler(actions) ::= <<
int <actor.simpleName>::schedule()
{
	getFifoStatus();

	bool res = true;
	int i = 0;
  
	while (res) 
	{
		res = false;
		<if(actions)>
		<schedulingTest(actions)>
		<endif>
	}
	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
<actionTrace(nextState.action)>
<nextState.action.body>();
_FSM_state = state_<nextState.targetState>;
res = true;
>>

actionTestState(nextState) ::= <<
if(<inputPattern(nextState.action.inputPattern)>isSchedulable_<nextState.action>())
{
	<if(nextState.action.outputPattern)>
	if(<outputPattern(nextState.action.outputPattern)>)
	{
		<actionCallState(nextState)>
	}
	<else>
	<actionCallState(nextState)>
	<endif>
}>>

schedulingTestState(nextStates) ::= <<
<nextStates: actionTestState(); separator=" else ">
>>

stateScheduler(transition) ::= <<
bool <actor.simpleName>::<transition.sourceState>_state_scheduler()
{
	bool res = false;
	<schedulingTestState(nextStates=transition.nextStateInfo)>
	return res;
}

>>

switch(transitions) ::= <<
switch (_FSM_state)
{
<transitions: {transition | case state_<transition.sourceState>:
	res = <transition.sourceState>_state_scheduler();
	break;
}>
default:
	std::cout \<\< "unknown state: " \<\< _FSM_state \<\< std::endl;
	break;
}
if (res){i++;}
>>

schedulerFSM(actions, fsm) ::= <<
<if(actions)>
bool <actor.simpleName>::outside_FSM_scheduler()
{
	bool res = false;
	int i = 0;
	<schedulingTest(actions)>
	return res;
}


<endif>
<fsm.transitions: stateScheduler(); separator="\n">
int <actor.simpleName>::schedule()
{
	getFifoStatus();

	bool res = true;
	int i = 0;

	while (res)
	{
		res = false;
		
		<if(actions)>
		if(outside_FSM_scheduler())
		{
			res = true;
			i++;
		}
		else
		{
			<switch(fsm.transitions)>
		}
		<else>
		<switch(fsm.transitions)>
		<endif>
	}
	return i;
}

>>

constructor(parameters, stateVars) ::= <<
<if (actor.parameters.list)>
<actor.simpleName>::<actor.simpleName>(const char* instanceName, <parameters: {param | <param.type> <param>}; separator=", ">, AKA_PROFILING_MODE eProfilingMode)
<else>
<actor.simpleName>::<actor.simpleName>(const char* instanceName, AKA_PROFILING_MODE eProfilingMode)
<endif>
:
<parameters: {param | <param>(<param>),}; wrap, separator="\n">
<if(actor.actionScheduler.fsm)>
_FSM_state(state_<actor.actionScheduler.fsm.initialState>),
<endif>
<stateVars : StateVarAllocation()>
ActorAKA("<actor.simpleName>", instanceName, <length(actor.inputs.list)>, <length(actor.outputs.list)>, eProfilingMode)
{
<stateVars : ListStateVarInitialization()>
}

>>

destructor(stateVars) ::= <<
<actor.simpleName>::~<actor.simpleName>()
{
	<stateVars: StateVarDestruction()>
}

>>


///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
#include \<iostream\>
#include \<string.h\>

#include "<actor.simpleName>.h"

using namespace <actor.packageAsList; separator="::">;

#ifdef __TRACE_CAPTURE__
extern TraceAka g_oTracer;
#endif

const char* <actor.simpleName>::className = "<actor.simpleName>";

<defineConstantVars(actor.stateVars.list)>

<constructor(parameters=actor.parameters.list, stateVars=actor.stateVars.list)>

<destructor(stateVars=actor.stateVars.list)>

void <actor.simpleName>::initializeActor()
{
}


////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
<actor.procs.list: procedure()>
////////////////////////////////////////////////////////////////////////////////
// Actions
<actor.actions: action()>
<if(actor.initializes)>
////////////////////////////////////////////////////////////////////////////////
// Initializes
<actor.initializes: action()>
void <actor.simpleName>::initialize()
{
	bool res = true;
	int i = 0;

	<if(actor.initializes)>
	<schedulingTest(actor.initializes)>
	<endif>
}

<endif>
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
<if(actor.actionScheduler.fsm)>
<schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)>
<else>
<scheduler(actions=actor.actionScheduler.actions)>
<endif>


void <actor.simpleName>::getFifoStatus()
{
<if(actor.inputs.list)>
  	for(int i=0; i\<<actor.simpleName>_nbInputs; i++) 
	{
		m_arrAvailStatus[i] = m_poTabIn[i]-\>getCount();
	}
<endif>
<if(actor.outputs.list)>
	for(int i=0; i\<<actor.simpleName>_nbOutputs; i++) 
	{
		m_arrRoomStatus[i] = m_poTabOut[i]-\>getRooms();
	}
<endif>
}

>>
